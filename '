use std::collections::HashSet;

use glam::{vec3, Quat, Vec3};
use russimp_sys::built_info::PKG_AUTHORS;

use crate::{camera::Camera, entity_manager::EntityManager, enums_types::{CameraState, EntityType, Faction}, terrain::Terrain};

pub fn update(em: &mut EntityManager, terrain: &Terrain, dt: f32, camera: &Camera, pressed_keys: &HashSet<glfw::Key>) {
    
    let player_keys = em.get_ids_for_faction(Faction::Player);
    let enemy_keys = em.get_ids_for_faction(Faction::Enemy);
    let static_keys = em.get_ids_for_faction(Faction::Static);
    // =============================================================
    // Player Pass
    // =============================================================
    if camera.move_state != CameraState::Free {
        handle_player_movement(pressed_keys, em, player_keys, dt, camera, terrain);
    }
    // =============================================================
    // Enemy Pass
    // =============================================================
    handle_enemy_movement();
}

pub fn handle_player_movement(pressed_keys: &HashSet<glfw::Key>, em: &mut EntityManager, player_keys: Vec<usize>, delta: f32, camera: &Camera, terrain: &Terrain) {
    // We don't want multiple players yet, and we want at least one. Both these things can/will change later
    assert!(player_keys.len() == 1 && player_keys.len() > 0);

    let player_key = *player_keys.first().unwrap();

    let speed = 5.0 * delta;
    let mut move_dir = vec3(0.0, 0.0, 0.0);

    let forward_flat = vec3(camera.forward.x, 0.0, camera.forward.z).normalize();
    let right_flat = vec3(camera.right.x, 0.0, camera.right.z).normalize();

    if pressed_keys.contains(&glfw::Key::W) {
        move_dir += forward_flat;
    }
    if pressed_keys.contains(&glfw::Key::S) {
        move_dir -= forward_flat;
    }
    if pressed_keys.contains(&glfw::Key::D) {
        move_dir += right_flat;
    }
    if pressed_keys.contains(&glfw::Key::A) {
        move_dir -= right_flat;
    }

    let mut velocity = vec3(0.0, 0.0, 0.0);
    let new_rotation: Option<Quat>;

    let new_state = if move_dir.length_squared() > 0.0 {
        move_dir = move_dir.normalize();
        velocity = move_dir * speed;

        let rot =Quat::from_rotation_y(f32::atan2(-move_dir.x, -move_dir.z));
        new_rotation = Some(rot * em.transforms.get(player_key).unwrap().original_rotation.normalize());
        "Run"
    } else {
        new_rotation = None;
        "Idle"
    };

    let transform = em.transforms.get_mut(player_key).unwrap();
    let rotator = em.rotators.get_mut(player_key).unwrap();
    if rotator.next_rot != rotator.cur_rot {
        rotator.blend_factor += delta as f32 / rotator.blend_time;
        if rotator.blend_factor >= 1.0 {
            rotator.blend_factor = 0.0;
            rotator.cur_rot = rotator.next_rot;
        }
    }
    let animator = em.animators.get_mut(player_key).unwrap();

    animator.next_animation = new_state.to_string();

    if let Some(rot) = new_rotation {
        if rotator.blend_factor == 0.0 && rot != rotator.cur_rot {
            rotator.next_rot = rot;
        }

        transform.rotation = rotator.cur_rot.slerp(rotator.next_rot, rotator.blend_factor);
    }

    transform.position += velocity;
}

pub fn handle_enemy_movement(em: &mut EntityManager, terrain: &Terrain, dt: f32) {

    for model in em.ani_models.iter() {
        if let (
            Some(trans),
            Some(faction),
            Some(rotator),
        ) = (
            em.transforms.get_mut(model.key()),
            em.factions.get_mut(model.key()),
            em.rotators.get_mut(model.key()),
        ) {
            // Adjust for terrain height
            // TODO: This is handling the player terrain logic, we should move this into the player and leave this in the faction check block
            trans.position.y = terrain.get_height_at(trans.position.x, trans.position.z);
            
            if *faction != Faction::Player {
                let speed = 3.2 * dt as f32;
                let destination = em.destinations.get(model.key()).unwrap();
                let direction = *destination - trans.position;
                let distance = direction.length();

                if distance > 0.001 {
                    // translation
                    let calc_movement = direction.normalize() * speed.min(distance);

                    trans.position += calc_movement;

                    // Rotation
                    let movement_dir = direction.normalize();
                    // let up = Vec3::Y;
                    

                    // TODO: This clamps rotation to around Y, which should be not the case forever.
                    let angle = f32::atan2(-movement_dir.x, -movement_dir.z);
                    let target_rot = Quat::from_rotation_y(angle) * trans.original_rotation;

                    // let target_rot = Quat::from_rotation_arc(-Vec3::Z, movement_dir) * trans.original_rotation;

                    if rotator.blend_factor == 0.0 && target_rot != rotator.cur_rot {
                        rotator.next_rot = target_rot;
                    }

                    if rotator.next_rot != rotator.cur_rot {
                        rotator.blend_factor += dt / rotator.blend_time;
                        if rotator.blend_factor >= 1.0 {
                            rotator.blend_factor = 0.0;
                            rotator.cur_rot = rotator.next_rot;
                        }
                    }

                    trans.rotation = rotator.cur_rot.slerp(rotator.next_rot, rotator.blend_factor);
                }
            }

        }
    }
}

pub fn handle_static_movement() {
    // TODO: This terrain adjustment should be in the collision system file.

    for model in em.models.iter() {
        if let Some(ent_type) = em.entity_types.get(model.key()) {
            if ent_type != &EntityType::Terrain {
                if let Some(trans) = em.transforms.get_mut(model.key()) {
                    trans.position.y = terrain.get_height_at(trans.position.x, trans.position.z);
                }
            }
        }
    }
}

pub fn handle_enemy_movement_old(em: &mut EntityManager, terrain: &Terrain, dt: f32) {
    // TODO: This terrain adjustment should be in the collision system file.
    for model in em.models.iter() {
        if let Some(ent_type) = em.entity_types.get(model.key()) {
            if ent_type != &EntityType::Terrain {
                if let Some(trans) = em.transforms.get_mut(model.key()) {
                    trans.position.y = terrain.get_height_at(trans.position.x, trans.position.z);
                }
            }
        }
    }

    for model in em.ani_models.iter() {
        if let (
            Some(trans),
            Some(faction),
            Some(rotator),
        ) = (
            em.transforms.get_mut(model.key()),
            em.factions.get_mut(model.key()),
            em.rotators.get_mut(model.key()),
        ) {
            // Adjust for terrain height
            // TODO: This is handling the player terrain logic, we should move this into the player and leave this in the faction check block
            trans.position.y = terrain.get_height_at(trans.position.x, trans.position.z);
            
            if *faction != Faction::Player {
                let speed = 3.2 * dt as f32;
                let destination = em.destinations.get(model.key()).unwrap();
                let direction = *destination - trans.position;
                let distance = direction.length();

                if distance > 0.001 {
                    // translation
                    let calc_movement = direction.normalize() * speed.min(distance);

                    trans.position += calc_movement;

                    // Rotation
                    let movement_dir = direction.normalize();
                    // let up = Vec3::Y;
                    

                    // TODO: This clamps rotation to around Y, which should be not the case forever.
                    let angle = f32::atan2(-movement_dir.x, -movement_dir.z);
                    let target_rot = Quat::from_rotation_y(angle) * trans.original_rotation;

                    // let target_rot = Quat::from_rotation_arc(-Vec3::Z, movement_dir) * trans.original_rotation;

                    if rotator.blend_factor == 0.0 && target_rot != rotator.cur_rot {
                        rotator.next_rot = target_rot;
                    }

                    if rotator.next_rot != rotator.cur_rot {
                        rotator.blend_factor += dt / rotator.blend_time;
                        if rotator.blend_factor >= 1.0 {
                            rotator.blend_factor = 0.0;
                            rotator.cur_rot = rotator.next_rot;
                        }
                    }

                    trans.rotation = rotator.cur_rot.slerp(rotator.next_rot, rotator.blend_factor);
                }
            }

        }
    }
}

pub fn revolve_around_something(object: &mut Vec3, target: &Vec3, elapsed: f32, radius: f32, speed: f32) {
    let angle = elapsed * speed;

    object.x = target.x + radius * angle.cos();
    object.z = target.z + radius * angle.sin();
    object.y = target.y + 1.0;
}
